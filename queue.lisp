;; 已封装的队列类及其方法
(multiple-value-bind (s1 s2 s3 s4 s5 s6 s7)
  (let ((g (gensym)))
    (values
      `(defclass queue ()
	 ((,g :initform (cons nil nil))))
      `(defmethod enqueue (obj (q queue))
	 ;; 入队一个元素，将入队后的队列以列表形式返回
	 (if (null (car (slot-value q ',g)))
	   (setf (cdr (slot-value q ',g))
		 (setf (car (slot-value q ',g)) (list obj)))
	   (setf (cdr (slot-value q ',g))
		 (setf (cdr (cdr (slot-value q ',g))) (list obj))))
	 (car (slot-value q ',g)))
      `(defmethod dequeue ((q queue))
	 ;; 出队一个元素并返回，第2个返回值表示操作成功与否
	 (if (not (null (car (slot-value q ',g))))
	   (let ((retval (pop (car (slot-value q ',g)))))
	     (if (null (car (slot-value q ',g)))
	       (setf (cdr (slot-value q ',g)) nil))
	     (values retval t))
	   (values nil nil)))
      `(defmethod queue-size ((q queue))
	 ;; 返回队列中元素的个数
	 (length (car (slot-value q ',g))))
      `(defmethod print-queue ((q queue))
	 ;; 打印队列元素
	 (do ((e (car (slot-value q ',g)) (cdr e)))
	   ((null e))
	   (prin1 (car e))
	   (if (not (null (cdr e)))
	     (princ " "))))
      `(defmethod queue-front ((q queue))
	 ;; 查看队首元素，第2个返回值表示操作成功与否
	 (if (not (null (car (slot-value q ',g))))
	   (values (caar (slot-value q ',g)) t)
	   (values nil nil)))
      `(defmethod queue-back ((q queue))
	 ;; 查看队尾元素，第2个返回值表示操作成功与否
	 (if (not (null (cdr (slot-value q ',g))))
	   (values (cadr (slot-value q ',g)) t)
	   (values nil nil)))
      ))
  (eval s1)
  (eval s2)
  (eval s3)
  (eval s4)
  (eval s5)
  (eval s6)
  (eval s7))
